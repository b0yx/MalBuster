import sys
import os
import pyfiglet
import shutil
from colorama import Fore, Style, init
from elftools.elf.elffile import ELFFile # For parsing ELF files

# Initialize colorama for Windows compatibility
init(autoreset=True)

# Ensure we can import Main.py from the parent directory
parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

try:
    import MalwareAnalysis  
except ImportError:
    print("Error: Unable to import 'MalwareAnalysis.py'. Ensure you're running the script from the correct directory.")
    exit(0)

# Global variable for minimum string length
MINIMUM_LENGTH = 4  # Default minimum string length

def clear_screen():
    """Clears the terminal screen for better readability."""
    os.system('cls' if os.name == 'nt' else 'clear')

def display_banner():
    """Displays a stylized banner using pyfiglet."""
    try:
        terminal_width = shutil.get_terminal_size().columns
    except:
        terminal_width = 80  # Fallback width if terminal size cannot be determined

    banner = pyfiglet.figlet_format("ELF ANALYSER", font="slant")
    banner_lines = banner.split("\n")
    centered_banner = "\n".join(line.center(terminal_width) for line in banner_lines)

    print(Fore.CYAN + "=" * terminal_width)
    print(Fore.GREEN + centered_banner)
    print(Fore.CYAN + "=" * terminal_width + Style.RESET_ALL)

def display_menu():
    """Displays the main menu with colors."""
    clear_screen()
    display_banner()

    file_path = input(Fore.YELLOW + "Enter the path of the ELF file: ")

    print(Fore.YELLOW + f"""
    {Fore.BLUE}[1] {Fore.CYAN}Display ELF Header Information
    {Fore.BLUE}[2] {Fore.CYAN}Analyze Program Headers (Segments)
    {Fore.BLUE}[3] {Fore.CYAN}Analyze Section Headers (Sections)
    {Fore.BLUE}[2] {Fore.CYAN}Extract Strings from File
    {Fore.BLUE}[3] {Fore.CYAN}List Symbols
    {Fore.BLUE}[2] {Fore.CYAN}Check Dynamic Linking Information
    {Fore.BLUE}[3] {Fore.CYAN}Check Security Features
    {Fore.RED}[0] Exit
    
    """)

    choice = input(Fore.YELLOW + "Enter Your Choice: " + Style.RESET_ALL)
    handle_choice(choice)

def handle_choice(choice):
    """Handles menu selection."""
    global MINIMUM_LENGTH

    if choice == "1":
        print(Fore.GREEN + "Display ELF Header Information...")
        Elf_header(display_menu.file_path)
        
    elif choice == "2":
        print(Fore.GREEN + "Analyzing program header (Segments Mode)...")
        Segment_header_analysis(display_menu.file_path)
    elif choice == "3":
        print(Fore.GREEN + "Saving extracted strings to file...")
        # Add functionality for saving strings to file here
    elif choice == "0":
        print(Fore.RED + "Returning to Malware Analysis Menu. Goodbye!")
        exit(0)
    else:
        print(Fore.RED + "Invalid Choice. Please Try Again.")
    
    input(Fore.YELLOW + "Press Enter to continue...")
    display_menu()
    
def Elf_header(file_path):
    try:
        with open(file_path, "rb") as f:
            Elf_file = ELFFile(f)
            Elf_header = Elf_file.header
            
            print("ELF File Header:")
            print(f"  Magic: {Elf_header['e_ident']}")
            print(f"  Class: {Elf_header['e_ident']['EI_CLASS']}")
            print(f"  Data: {Elf_header['e_ident']['EI_DATA']}")
            print(f"  Version: {Elf_header['e_ident']['EI_VERSION']}")
            print(f"  OS/ABI: {Elf_header['e_ident']['EI_OSABI']}")
            print(f"  ABI Version: {Elf_header['e_ident']['EI_ABIVERSION']}")
            print(f"  Type: {Elf_header['e_type']}")
            print(f"  Machine: {Elf_header['e_machine']}")
            print(f"  Version: {Elf_header['e_version']}")
            print(f"  Entry Point: {hex(Elf_header['e_entry'])}")
            print(f"  Program Header Offset: {Elf_header['e_phoff']}")
            print(f"  Section Header Offset: {Elf_header['e_shoff']}")
            print(f"  Flags: {Elf_header['e_flags']}")
            print(f"  Header Size: {Elf_header['e_ehsize']}")
            print(f"  Program Header Entry Size: {Elf_header['e_phentsize']}")
            print(f"  Number of Program Headers: {Elf_header['e_phnum']}")
            print(f"  Section Header Entry Size: {Elf_header['e_shentsize']}")
            print(f"  Number of Section Headers: {Elf_header['e_shnum']}")
            print(f"  Section Header String Table Index: {Elf_header['e_shstrndx']}")
    except FileNotFoundError:
        print(f"Error The file {file_path} was not found.")
    except Exception as e:
        print(f"An error occurred: {e}")

def Segment_header_analysis(file_path):
    try:
        with open(file_path, "rb") as f:
            Elf_file = ELFFile(f)
            """ Check if the program has a header table"""
            if not Elf_file.has_dynamic_segments():
                print("This ELF file has no program headers.")
                return

            print("Program Headers (Segments):")
            print("  Type           Offset   VirtAddr   PhysAddr   FileSiz   MemSiz   Flags  Align")
            for segment in Elf_file.iter_segments():
                p_type = segment['p_type']
                p_offset = segment['p_offset']
                p_vaddr = segment['p_vaddr']
                p_paddr = segment['p_paddr']
                p_filesz = segment['p_filesz']
                p_memsz = segment['p_memsz']
                p_flags = segment['p_flags']
                p_align = segment['p_align']
            
        """Converting flags into readable format"""
        flags_str = ""
        if p_flags & 0x1: flags_str += "R"  # Readable
        if p_flags & 0x2: flags_str += "W"  # Writable
        if p_flags & 0x4: flags_str += "X"  # Executable

        """Print the segment information"""
        print(f"  {p_type:<14} {p_offset:08x} {p_vaddr:08x} {p_paddr:08x} {p_filesz:08x} {p_memsz:08x} {flags_str:<6} {p_align:x}")
        
        if p_type == 'PT_INTERP':
            print(f"    Interpreter: {segment.get_interp_name()}")
        elif p_type == 'PT_DYNAMIC':
            print("    Dynamic Linking Information:")
        
    except FileNotFoundError:
        print(f"Error: The file '{file_path}' was not found.")
    except Exception as e:
        print(f"An error occurred: {e}")
                
# Start the program if executed directly
if __name__ == "__main__":
    display_menu()